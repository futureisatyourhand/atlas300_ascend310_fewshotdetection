#include <unistd.h>
#include <thread>
#include <iostream>
#include <fstream>
#include <algorithm>
#include "main.hpp"
#include "hiaiengine/api.h"
#include <string.h>
#include <opencv2/opencv.hpp>
#include "BatchImageParaWithScale.h"
#include "CommandLine.h"
#include <sys/time.h>
//#include "cnpy.h"
//#include <complex>
#include <stdio.h>
#include <stdlib.h>





using namespace std;

uint32_t MAX_SLEEP_TIMER = 2;
static uint32_t CHANNEL = 3;
static uint32_t MODEL_W = 17;
static uint32_t MODEL_H = 21;
static uint32_t BS = 1; 
uint32_t GRAPH_ID = 1;
uint32_t INPUT_ENGINE_ID = 2;
uint32_t OUTPUT_ENGINE_ID = 3;
char input_data_name[200];
std::string dtype_name;
long long total_len;
int dtype_size;
int dtype_idx;
int pic_size; 
float* data;

bool g_test_flag = false;
std::mutex g_test_mutex;
std::condition_variable g_test_cv;



HIAI_REGISTER_DATA_TYPE("BatchImageParaWithScaleT", BatchImageParaWithScaleT);
HIAI_REGISTER_DATA_TYPE("EngineTransT", EngineTransT);
HIAI_StatusT CustomDataRecvInterface::RecvData(const std::shared_ptr<void>& message)
{
    //std::cout << "[RecvData] called" << std::endl;
    std::unique_lock<std::mutex> lck(g_test_mutex);
    g_test_flag = true;
    g_test_cv.notify_all();

    return HIAI_OK;
}

/**
* @ingroup FasterRcnnDataRecvInterface
* @brief RecvData RecvDataÂõûË∞ÉÔºå‰øùÂ≠òÊñá‰ª?* @param [in]
*/

// Init and create graph
HIAI_StatusT HIAI_InitAndStartGraph()
{
    // Step1: Global System Initialization before using HIAI Engine
    HIAI_StatusT status = HIAI_Init(0);

    // Step2: Create and Start the Graph
    status = hiai::Graph::CreateGraph("/home/liqian/inferences/InferLib/out/graph0.config");
    if (status != HIAI_OK)
    {   std::cout << "[HIAI_InitAndStartGraph] Fail to start graph" << std::endl;
        HIAI_ENGINE_LOG(status, "Fail to start graph");
        return status;
    }
    printf("CreateGraph success.\n");


    // Step3
    std::shared_ptr<hiai::Graph> graph = hiai::Graph::GetInstance(GRAPH_ID);
    if (nullptr == graph)
    {
        HIAI_ENGINE_LOG("Fail to get the graph-%u", GRAPH_ID);
        return status;
    }

    hiai::EnginePortID target_port_config;
    target_port_config.graph_id = GRAPH_ID;
    target_port_config.engine_id = OUTPUT_ENGINE_ID;
    target_port_config.port_id = 0;
    graph->SetDataRecvFunctor(target_port_config,
    std::shared_ptr<CustomDataRecvInterface>( new CustomDataRecvInterface()));

    printf("SetDataRecvFunctor success.\n");
    
    return HIAI_OK;
}


/*
bool ParseAndCheckCommandLine(int argc, char *argv[]) {
    // ---------------------------Parsing and validation of input args--------------------------------------
    gflags::ParseCommandLineNonHelpFlags(&argc, &argv, true);
    if (FLAGS_h) {
        showUsage();
        return false;
    }

    std::fstream fileTest;
    fileTest.open(FLAGS_i.c_str(), ios::in);
    if(!fileTest){
        std::cout << "[ERROR] Input file--"<< FLAGS_i << " doesn't exit!" << std::endl;
        return false;
    }

    return true;
}

uint8_t* load_npy(cnpy::NpyArray &arr){
	const string s1 = "int8";
	const string s2 = "int16";
	const string s3 = "int32";
	const string s4 = "int64";
	const string s5 = "float32";
	const string s6 = "float64";
	uint8_t *mat_dat;
	
	std::cout << "Set type: " << dtype_name << ",   NpyArray Val num: " << arr.num_vals << ",  Word size: " << arr.word_size << std::endl;
	if (dtype_name==s1){	
			if (arr.word_size != sizeof(char)){
				cout << "whb npy' s data_type size is not equal to " << dtype_name << ':' << sizeof(char) << endl;
				return NULL;
			}
		 dtype_size = 1;
		 dtype_idx = 1;
    		 mat_dat = (uint8_t *)arr.data<std::complex<char>>();

		}
	else if (dtype_name==s2)
		{	
			if (arr.word_size != sizeof(short)){
				cout << "npy' s data_type size is not equal to " << dtype_name << ':' << sizeof(short) << endl;
				return NULL;
			}
		 dtype_size = 2;
		 dtype_idx = 2;
    		 mat_dat = (uint8_t *)arr.data<std::complex<short>>();
		}
	else if (dtype_name==s3)
		{	
			if (arr.word_size != sizeof(int)){
				cout << "npy' s data_type size is not equal to " << dtype_name << ':' << sizeof(int) << endl;
				return NULL;
			}
		 dtype_size = 4;
		 dtype_idx = 3;
    		 mat_dat = (uint8_t *)arr.data<std::complex<int>>();
		}
	else if (dtype_name==s4)
		{	
			if (arr.word_size != sizeof(long)){
				cout << "npy' s data_type size is not equal to " << dtype_name << ':' << sizeof(long) << endl;
				return NULL;
			}
		 dtype_size = 8;
		 dtype_idx = 4;
    		 mat_dat = (uint8_t *)arr.data<std::complex<long>>();
		}
	else if (dtype_name==s5)
		{	
			if (arr.word_size != sizeof(float)){
				cout << "npy' s data_type size is not equal to " << dtype_name << ':' << sizeof(float) << endl;
				return NULL;
			}
		 dtype_size = 4;
		 dtype_idx = 5;
    		 mat_dat = (uint8_t *)arr.data<std::complex<float>>();
		}
	else if (dtype_name==s6)
		{	
			if (arr.word_size != sizeof(double)){
				cout << "npy' s data_type size is not equal to " << dtype_name << ':' << sizeof(double) << endl;
				return NULL;
			}
		 dtype_size = 8;
		 dtype_idx = 6;
    		 mat_dat= (uint8_t *)arr.data<std::complex<double>>();
		}
	else{
		 dtype_size = 0;
		 dtype_idx = 0;
		cout << "npy' s data_type not found! \n";
		return NULL;
	}	
    
    //make sure the loaded data matches the saved data
    //assert(arr.word_size == sizeof(std::complex<float>));
    //assert(arr.shape.size() == 3 && arr.shape[0] == Nz && arr.shape[1] == Ny && arr.shape[2] == Nx);
	cout << "Input data shape: [" ;
	total_len = 1;
    	for(int i = 0; i < arr.shape.size();i++){ 
		std::cout << arr.shape[i] << ", ";
		total_len *= arr.shape[i];
	}
	std::cout << ']' << std::endl;
	return mat_dat;	
}
*/


long long SendData(std::shared_ptr<hiai::Graph> graph, hiai::EnginePortID engine_id, cv::Mat orig_img, int model_width, int model_height, uint8_t *mat_dat, long long sent_cnt)
{
    if (graph == nullptr)
    {
        std::cout << "[SendData] graph is null." << std::endl;
        return -1;
    }


    std::shared_ptr<BatchImageParaWithScaleT> image_handle = std::make_shared<BatchImageParaWithScaleT>();

    NewImageParaT imgData;
    imgData.img.channel = CHANNEL;
    //imgData.img.format = BGR888;

    //To prepare the destination image, the original image will be resize to the top left square area of the destination image.
    //The rest space of the destination area is payed without initialized.
    //int pic_size = model_width * model_height * CHANNEL;
    static long long bs_num;
    //std::shared_ptr<uint8_t> data(new uint8_t[pic_size*BS], std::default_delete<uint8_t[]>());
    //float* data = new float[pic_size*BS];
    int jj=0;
    switch (dtype_idx){
        case 1:
    		for (jj=0; jj<pic_size*BS && jj+sent_cnt < total_len; jj++)
    		    	*(data+jj) =  (float)(*((char*)(mat_dat + (sent_cnt+jj)*dtype_size)));
		break;
        case 2:
    		for (jj=0; jj<pic_size*BS && jj+sent_cnt < total_len; jj++)
    		    	 *(data+jj) = (float)(*((short*)(mat_dat + (sent_cnt+jj)*dtype_size)));
		break;
        case 3:
    		for (jj=0; jj<pic_size*BS && jj+sent_cnt < total_len; jj++)
    		    	 *(data+jj) = (float)(*((int*)(mat_dat + (sent_cnt+jj)*dtype_size)));
		break;
        case 4:
    		for (jj=0; jj<pic_size*BS && jj+sent_cnt < total_len; jj++)
    		    	 *(data+jj) = (float)(*((long*)(mat_dat + (sent_cnt+jj)*dtype_size)));
		break;
        case 5:
    		for (jj=0; jj<pic_size*BS && jj+sent_cnt < total_len; jj++){
    		    	 //*(data+jj) = (float)(*((float*)(mat_dat + (sent_cnt+jj)*dtype_size)));
    		    	 *(data+jj) = (*((float*)(mat_dat + (sent_cnt+jj)*dtype_size)));
			//if (1280+128<jj && jj<1280+256) 
			//	cout << *(data+jj) << ' ' << endl;
		}
		break;
        case 6:
    		for (jj=0; jj<pic_size*BS && jj+sent_cnt < total_len; jj++){
    		    	 //*(int*)(data+jj) = (int)((*((double*)(mat_dat + (sent_cnt+jj)*dtype_size)))*40000000);
    		    	 *(data+jj) = (float)(*((double*)(mat_dat + (sent_cnt+jj)*dtype_size)));
			}
		break;
	default:
		return sent_cnt; 
    		
    }

    bs_num++;
    std::cout << "NO.BS: " << bs_num << "   model_width:" << model_width << "    model_height:" << model_height << "    image size:" << pic_size << std::endl;

    float *ptr = data;
    int cnt;

    imgData.img.size = pic_size;
    imgData.img.width = model_width;
    imgData.img.height = model_height;
    image_handle->b_info.batch_size = BS;
    image_handle->b_info.is_first = true;
    image_handle->b_info.is_last = true;
    image_handle->b_info.max_batch_size = BS;
    image_handle->b_info.batch_ID = 0;

    //std::shared_ptr<float> data1(new float[pic_size], std::default_delete<float[]>());
    std::shared_ptr<float> data1;
    for (cnt=0; cnt < BS && cnt+sent_cnt < total_len ; cnt++){
	//whb call here!!
        data1.reset(new float[pic_size], std::default_delete<float[]>());
        memcpy(&(*data1), ptr + cnt*(imgData.img.size), imgData.img.size*sizeof(float));
    	imgData.img.data = data1;//std::shared_ptr<float_t> (ptr + cnt*(imgData.img.size));
        //f = fopen(std::to_string(cnt).c_str(), "w");
        //fwrite(&(*data1), imgData.img.size, sizeof(float), f);
        //fclose(f);
	//imgData.f_info.is_first = cnt==0 ? true : false; 
	//imgData.f_info.is_last = cnt==(BS-1) ? true : false; 
	imgData.f_info.frame_ID = cnt;
    	image_handle->v_img.push_back(imgData);
    	image_handle->b_info.frame_ID.push_back(cnt);
        //std::cout << "image[0]=" << *(ptr + cnt*(imgData.img.size)+25) << ',' << "image[1]=" << *(ptr + cnt*(imgData.img.size)+42*128+10+cnt) << '\n';
    }
    if( HIAI_OK != graph->SendData(engine_id, "BatchImageParaWithScaleT", std::static_pointer_cast<void>(image_handle)))
    {
        std::cerr << "[SendData] send data error" << std::endl;
        return -1;
    }

	return sent_cnt + pic_size*cnt;
}


int main(int argc, char* argv[]){
//int infer(float *matrix, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7){

    GRAPH_ID = 1;
    MAX_SLEEP_TIMER = 2;
    INPUT_ENGINE_ID = 2;
    OUTPUT_ENGINE_ID = 3;

    struct  timeval start;
    struct  timeval end;
    double  diff;


    HIAI_StatusT ret = HIAI_OK;
    //int iter = 100;
    long long have_sent;



    int count = 0;
    int model_width = MODEL_W;
    int model_height = MODEL_H;
    pic_size = model_width * model_height * CHANNEL;
    data = new float[pic_size*BS];
    //GRAPH_ID = 1;

    float *matrix = new float[5664*8];

    BS 	    = 8;
    CHANNEL = 1;
    MODEL_W = 1;
    MODEL_H = 5664;
    dtype_idx = 5;
    dtype_idx = 4;
    total_len = 5664*8;

    matrix[0] = 1314.0;


    char buf[80];   
    getcwd(buf,sizeof(buf));   
    printf("current working directory: %s\n", buf);   
    // ------------------------------ Parsing and validation of input args ---------------------------------

    // 1.create graph
    ret = HIAI_InitAndStartGraph();
    if (HIAI_OK != ret)
    {
        std::cout << "[main] Fail to start graph" << std::endl;
        HIAI_ENGINE_LOG("Fail to start graph");;
        return -1;
    }

    // 2.send data
    std::shared_ptr<hiai::Graph> graph = hiai::Graph::GetInstance(GRAPH_ID);
    if (nullptr == graph)
    {
        std::cout << "[main] Fail to get the graph" << std::endl;
        HIAI_ENGINE_LOG("Fail to get the graph-%u", GRAPH_ID);
        return -1;
    }

    hiai::EnginePortID engine_id;
    engine_id.graph_id = GRAPH_ID;
    engine_id.engine_id = INPUT_ENGINE_ID;
    engine_id.port_id = 0;
	

    //cnpy::NpyArray arr = cnpy::npy_load(input_data_name);
    //uint8_t *mat_dat = (uint8_t*)load_npy(arr);
    uint8_t *mat_dat = (uint8_t*)matrix;

    if (mat_dat == NULL){
        printf("Finish inference.\n");    
        hiai::Graph::DestroyGraph(GRAPH_ID);
        return 0;
    }

    have_sent = 0;
    do
    {
        //cv::Mat mat_img;
    	//gettimeofday(&start,NULL);

    	cv::Mat mat_img = cv::imread(FLAGS_i.c_str());
    	//gettimeofday(&end,NULL);
	//diff = 1000000 * (end.tv_sec-start.tv_sec)+ end.tv_usec-start.tv_usec;

        have_sent = SendData(graph, engine_id, mat_img, model_width, model_height, mat_dat, have_sent);

        //std::cout << "[main] to send image usetime = " << std::to_string(diff) << "us" << std::endl;


        std::unique_lock<std::mutex> lck(g_test_mutex);
        g_test_cv.wait_for(lck, std::chrono::seconds(MAX_SLEEP_TIMER), [] {return g_test_flag;});
        g_test_flag = false;
        count++;

	//if(count % 100 == 0)
	//	printf("process %d iter..\n", count);
    } while(have_sent<total_len);// && count<iter);


    double *dd = (double*)matrix;
    *dd = 1315.0;

    printf("Finish inference.\n");    
    hiai::Graph::DestroyGraph(GRAPH_ID);
    delete data;
    sleep(2);
    return 0;
}
